import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserLogic.grammar".
 */
public class ParserLogic extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obaaal144SnL$F38CPnkXPxElOnO4uIDpSE3Wuk4ea4eb48i4m8dm3FgPz6pjJNbU$MKp" +
		"4HNL#zUhLlwlwLNS3E3C6DGYZtX9405qODUVMnU4YYJJQq848nj2ilX$3655VWsxqQct85C" +
		"mjPseHysVCJMNTNDCrOL3kYguE3NANT55MVNT1ruACziteMTMQa4RGQBFzjq$Ph4DeHJiwq" +
		"OC#363GV05m46AYa3sRo#ScUQ$d6faunfLnfdNuxeBgmpnPlNg7PuoKriBkvlAi$Wn#rFrQ" +
		"ueTp$t01kO2ULQrkAKCvstzwrsQDsXnUJl$oslYn5Ru7lwqQOmhKDH8cwwflI3UbMwJR6yj" +
		"las6oGoP9bioG79aZHsIUd905CaGMjNP9kanIP8KS5lTMxPGalJ7pvOkPfIbfyImJqYdfTD" +
		"LUizA5OdRfhdHFcgrOavNkIm#akSgzA#xFU7cWPZx91taZh#JTphwOP$pHp1F9aqVh7iozk" +
		"LCfnSifuTel7BJ$LNdiuV0h1qL0wbYI7Fz6#XlUBMOL");

	private final Action[] actions;

	public ParserLogic() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] S = AE
			Action.RETURN,	// [1] S = LE
			Action.RETURN,	// [2] S = CE
			new Action() {	// [3] AE = AE.x PLUS AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() + y.getArithEX());
				}
			},
			new Action() {	// [4] AE = AE.x MINUS AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() - y.getArithEX());
				}
			},
			new Action() {	// [5] AE = MINUS AE.x
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 2];
					final ArithEX x = (ArithEX) _symbol_x.value;
					return new ArithEX(-x.getArithEX());
				}
			},
			new Action() {	// [6] AE = AE.x TIMES AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() * y.getArithEX());
				}
			},
			new Action() {	// [7] AE = AE.x DIV AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() / y.getArithEX());
				}
			},
			new Action() {	// [8] AE = LPAR AE.x RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 2];
					final ArithEX x = (ArithEX) _symbol_x.value;
					return new ArithEX(x.getArithEX());
				}
			},
			new Action() {	// [9] AE = NUMBER.x
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final Number x = (Number) _symbol_x.value;
					return new ArithEX(x.doubleValue());
				}
			},
			new Action() {	// [10] LE = LE.x AND LE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getLogicVa() && y.getLogicVa());
				}
			},
			new Action() {	// [11] LE = LE.x OR LE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getLogicVa() || y.getLogicVa());
				}
			},
			new Action() {	// [12] LE = NOT LE.x
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 2];
					final ArithEX x = (ArithEX) _symbol_x.value;
					return new ArithEX( ! x.getLogicVa() );
				}
			},
			new Action() {	// [13] LE = LPAR LE.x RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 2];
					final ArithEX x = (ArithEX) _symbol_x.value;
					return new ArithEX(x.getLogicVa());
				}
			},
			new Action() {	// [14] LE = TRUE.x
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final Boolean x = (Boolean) _symbol_x.value;
					return new ArithEX(x.booleanValue());
				}
			},
			new Action() {	// [15] LE = FALSE.x
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final Boolean x = (Boolean) _symbol_x.value;
					return new ArithEX(x.booleanValue() );
				}
			},
			new Action() {	// [16] CE = AE.x LT AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() < y.getArithEX());
				}
			},
			new Action() {	// [17] CE = AE.x LG AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() > y.getArithEX());
				}
			},
			new Action() {	// [18] CE = AE.x LLE AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() <= y.getArithEX());
				}
			},
			new Action() {	// [19] CE = AE.x GE AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() >= y.getArithEX());
				}
			},
			new Action() {	// [20] CE = AE.x EQ AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() == y.getArithEX());
				}
			},
			new Action() {	// [21] CE = AE.x NE AE.y
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_x = _symbols[offset + 1];
					final ArithEX x = (ArithEX) _symbol_x.value;
					final Symbol _symbol_y = _symbols[offset + 3];
					final ArithEX y = (ArithEX) _symbol_y.value;
					return new ArithEX(x.getArithEX() != y.getArithEX());
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
