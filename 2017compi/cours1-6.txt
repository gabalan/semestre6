--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
STAGE GRAMMAIRES 
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
cours 1 (Lundi 15/01/18) 
-------------------------
-systeme de réécriture semi-Thuéien
-grammaire algébrique
-dérivation- dérivation gauche-dérivation droite;
-langage algébrique

cours 2 (Mardi 16/01/18):
-------------------------
- arbre de dérivation
- parcours d'un arbre de dérivation <--> dérivations de la frontière de l'arbre
- ambiguité d'une grammaire
- non-terminaux productifs, accessibles
- réduction d'une grammaire algébrique à une grammaire dont
tout non-terminal est productif et accessible

[4\times 1h 20 de TD sur les grammaires algébriques]

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
COMPILATION
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
cours 3 (Vendredi 19/01/18):
---------------------------
- Langage IMP:
 * syntaxe (définie par une grammaire algébrique)
 [qui s'avere ambigue, mais ils s'en apercevront plus tard]
 * sémantique: la sémantique operationnelle a petits pas (defimp.pdf ci-joint).
 
cours 4 (Lundi 22/01/18):
-----------------------
- Un exemple de programme imp (pex4.ip ci-joint)
- Deroulement de la semantique operationelle a petits pas sur deux exemples
(un avec seulement des operations arith et des affectations; le second avec un while).
- Notions de compilateur et d'interprete (ou interpreteur).
N.B. l'existence d'un programme d'interpretation I pour le langage L, sur la machine M
est assuré dès que M est une machine "universelle".
- Schema general des phases d'un compilateur.
- sur l'exemple pex4.ip:
 * analyse lexicale
 * analyse syntaxique
 * production de code intermediaire (voir pex4.res)
 * production de code Y86 (voir pex4.res)
 
cours 5 (Vendredi 26/01/17):
-------------------------
Analyse lexicale.

1- Langages rationnels versus reconnaissables
  * bref rappel
  * automates a transitions regulieres:
  \begin{defi}
  \label{defi_generale}
  Un {\em automate} fini g\'en\'eralis\'e est un 5-uplet,
  ${\cal A}= <X,Q,D,A,\delta>$ o\`u
  \begin{itemize}
  \item $X$ est un ensemble fini,l'alphabet d' entr\'ee
  \item $Q$ est un ensemble fini, l' ensemble des \'etats
  \item $D \subset Q$ est l' ensemble des etats de d\'epart
  \item $A \subset Q$ est l' ensemble des etats d'arriv\'ee
  \item $\delta \subset Q \times REGEXP(X) \times Q$ est l' ensemble des
  transitions
  \end{itemize}
  \end{defi}
  - theoreme: ils reconnaissent exactement les langages reguliers
  * exemple: aut. fini generalise reconnaissant (ab*cd*)* [voir mixte.l]
  * definitions regulieres enchassees (mais bien-fondees)
  
2- Generateur FLEX d'analyseurs lexicaux.
2.1-
  * principe: .l --> .c --> a.out
  * les 3 sections (definitions, regles, fonctions )
  * semantique des regles: prefixe le plus long, a egalite de longueur, premier lexeme
  * "start conditions"
  * quelques idiomes qui etendent les expressions regulieres:
   [a-z], point (tout caractere qui n'est pas un passage a la ligne)
  *exemple: mixte.l [fichier joint]
  
2.2- Extensions:
  * extensions des operations regulieres (comme dans sed, bash, etc ...):
   e^+, complement
  * contextes droits (indiques par /),
  * yyless(n),
  * REJECT,

En fait: je n'ai pas eu le temps de traiter les extensions (a faire en TD/TP)

cours 6 (Lundi 29/01/18):
-------------------------
Automates  pile.

0- Modèles de calcul: c'est quoi ? ca sert a quoi ?
Réponses:
- un modèle décrit mathématiquement un processus de calcul; les machines
sont concues à partir des modèles et en sont des incarnations.
- un modèle moins puissant que le modèle utilisé pour les ordinateurs,
peut être utile:
* calculs plus économes en temps
* on peut mieux "matriser" le modèle i.e. savoir
(par un calcul qui prend en entree A) si une instance A du modèle a une propriété
[accessibilité, conformité à la spécification, etc ... ]
- un modèle moins puissant peut être {\em simulé} dans une machine qui
incarne un modèle plus puissant.

1- Les automates:
classification en fonction de la "structure memoire" i.e. l'ensemble de ses valeurs
possibles et les operations autorisees:
a memoire finie, a 1 compteur, a p (\geq 2) compteurs, a pile, a arbre, a pile de piles,
a piles d'arbres, etc ...

2- Automates a pile: 
* definition, 
* exemple ($L= \{ u \in \{a,b\}^*\# \mid|u|_a = |u|_b \}$
* notion de determinisme (informel)

3- Theoreme 3: les langages engendres par les grammaires c.f. sont exactement les
langages reconus par des automates a pile.

Grammaires --> automates:
automate d'analyse descendante

N.B.: je laisse a Adrian le soin d'expliquer la reciproque: 
partant d'un automate a pile, comment construire une grammaire c.f.
