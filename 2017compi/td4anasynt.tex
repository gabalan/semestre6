\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{a4wide,amssymb,epsfig,latexsym,multicol,array,hhline}
\usepackage{listings,alltt}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

%%numerotations feuilles et exos
\newcommand{\Num}{4}
\newcounter{numexercice}
\newenvironment{exercice}{\addtocounter{numexercice}{1}
\noindent{\large \bf Exercice {\Num}.\thenumexercice }}{\bigskip}

%\input{macroscompi.tex}

\begin{document}
\thispagestyle{empty}

\noindent
Université Bordeaux\\
Licence, module Compilation, 2017/2018 

%\vfill
\begin{center}
{\Large \bf  TD4 -- Analyse syntaxique}
\end{center}

\begin{exercice}
\paragraph{Grammaire non LARL.}
\par

Soit la grammaire suivante écrite au format \textit{bison}, 

\begin{lstlisting}
statement_list:
	statement_list statement
	| statement
	;

statement:
	IDENTIFIER AFF expression SEMICOLON
	IF expression THEN statement
	| IF expression THEN statement ELSE statement
	| WHILE expression DO statement
	;

expression:
	IDENTIFIER
	| INTEGER
	| expression PLUS expression
	| expression MINUS expression
	| expression TIMES expression
	| expression DIV expression
	| expression OR expression
	| expression AND expression
	| MINUS expression
	| NOT expression
	| expression LT expression
	| expression LE expression
	| expression GT expression
	| expression GE expression
	| expression EQ expression
	| expression DIFF expression
	| LPAR expression RPAR
	;
\end{lstlisting}

Où les terminaux correspondent à ce tableau:

\begin{tabular}{|l|l|l||l|l|l||l|l|l||l|l|l||l|l|l||l|l|l||l|l|l||l|l|l||l|l|l||l|}
\hline
AFF &SEMICOLON &IF &THEN &ELSE &WHILE &DO &\\
\verb#:=# & \verb#;# & \verb#if# & \verb#then# & \verb#else# & \verb#while# & \verb#do# &\\
\hline
\hline
PLUS & MINUS & TIMES & DIV & OR & AND & NOT&\\
\verb#+# & \verb#-# & \verb#*# & \verb#/# & \verb#||# & \verb#&&# & \verb#!# &\\
\hline
\hline
LT & LE & GT & GE & EQ & DIFF & LPAR & RPAR\\
\verb#<# & \verb#<=# & \verb#># & \verb#>=# & \verb#=# & \verb#!=# &
                                                                     \verb#(# & \verb#)#\\
\hline 
\end{tabular}


\begin{enumerate}
\item Écrire un analyseur syntaxique qui respecte ces productions et
  le compiler avec l'option de débogage \verb#-v#.

\item Utiliser les règles de précédence des opérateurs pour corriger les
  erreurs affichées et pour respecter la sémantique usuelle des
  expressions et instructions.
\end{enumerate}


\end{exercice}

\begin{exercice}
\paragraph{Définition dirigée par la syntaxe pour une expression de
  la logique propositionnelle. Manipulation algébrique des expressions.}

\begin{enumerate}
\item Écrire en langage C une structure de données $Tree$ permettant de
  représenter un arbre binaire $t(tag, value, lhs, rhs)$. Où 

\begin{itemize}
 \item $tag$ est une valeur d'un énuméré
  \verb#enum Tag {AND, OR, NOT, IMPL, EQ# \verb#, CONSTANT# \verb#, VARIABLE}#
  désignant un opérateur logique
  ($\land, \lor, \lnot, \rightarrow, \leftrightarrow$), une constante
  ou une variable.
\item value est une valeur dans $\{0, 1\}$ désignant une constante, ou
  une valeur entière $i$ désignant une variable $p_i$.
\item $lhs$ et $rhs$ (\textit{left/right hand-side}) désignent les
  branches gauche (resp. droite) de l'arbre binaire.
\end{itemize}

\item Écrire en langage C une routine \verb$struct Tree *createTree()$ qui alloue une
  structure \verb$Tree$ pour représenter une
  expression logique.

\item Écrire en langage C une routine \verb$void printTree(struct Tree *tree)$ qui affiche un
  arbre sous la forme d'une formule de la logique propositionnelle.

\item Écrire une définition dirigée par la syntaxe en
  \texttt{lex/yacc} (\texttt{flex/bison}) pour obtenir une expression
  de la logique propositionnelle dans le format précédent. Pour
  faciliter l'écriture de la grammaire en \textit{Yacc}, on utilisera
  les propriétés de précédence des opérateurs. Nous rappelons que les
  opérateurs $\lor, \rightarrow, \leftrightarrow$ sont prioritaires
  sur $\land$ et que $\lnot$ est prioritaire sur tous les autres. Par
  ailleurs, tous les opérateurs binaires sont associatifs à gauche.

\item Mettre sous forme normale négative une formule propositionnelle
  donnée et l'afficher.

Pour cela, créer deux fonctions $fnn()$ et $neg()$ définies ainsi:

\begin{tabbing}
$fnn(0) = 0$\\
$fnn(1) = 1$\\
$fnn(p_i) = p_i$\\
$fnn(\lnot P) = neg(P)$\\
$fnn(P \lor Q) = fnn(P) \lor fnn(Q)$\\
$fnn(P \land Q) = fnn(P) \land fnn(Q)$\\
$fnn(P \rightarrow Q) = neg(P) \lor fnn(Q)$\\
$fnn(P \leftrightarrow Q) = (fnn(P) \land fnn(Q)) \lor (neg(P) \land neg(Q))$\\
$neg(0) = 1$\\
$neg(1) = 0$\\
$neg(p_i) = \lnot p_i$\\
$neg(\lnot P) = fnn(P)$\\
$neg(P \land Q) = neg(P) \lor neg(Q)$\\
$neg(P \lor Q) = neg(P) \land neg(Q)$\\
$neg(P \rightarrow Q) = fnn(P) \lor neg(Q)$\\
$neg(P \leftrightarrow Q) = (fnn(P) \land neg(Q)) \lor (neg(P) \land fnn(Q)$\\
\end{tabbing}

Exemple: $$((p \rightarrow q) \rightarrow p) \rightarrow p$$ devra
afficher $$((\lnot p \lor q) \land \lnot p)) \lor p$$
\end{enumerate}
\end{exercice}

\begin{exercice}
\par

Une grammaire attribuée est une extension d'une grammaire algébrique $G=(\Sigma, V_N, S, R)$ où 

\begin{itemize}
\item Dans un arbre de dérivation quelconque, on attache à chaque
  noeud étiqueté par $X$ un ensemble fini d’attributs: $A(X) = \{a_1(X), \dots, a_n(X)\}$.\\
  $A(X)$ est partitionné en deux ensembles disjoints: $A_s(X)$ et
  $A_h(X)$, respectivement les attributs synthétisés, et les attributs
  hérités. Les attributs synthétisés $A_s(X)$ sont ceux dont le calcul
  dépend des attributs attachés aux noeuds en dessous de $X$ dans
  l'arbre de dérivation. Les attributs hérités $A_h(X)$ sont ceux qui
  sont calculés à partir des noeuds frères ou père de $X$.

\item On associe à chaque production $p=X_0 \rightarrow X_1 \dots X_n$
  un ensemble de règles
  $R(p) = \{a_n(X_i) = f(a_m(X_j)_,\dots)\}$

\end{itemize}

Prenons un exemple simple inspiré de \cite{DBLP:journals/mst/Knuth68},
dans le domaine des grammaires attribuées et associant à chaque nombre
binaire, sa valeur décimale.

\begin{itemize}
\item $\Sigma = \{0, 1\}$

\item $S, N, B$ sont les symboles de la grammaire ($B$ pour les
  chiffres binaires et $N$ pour les nombres exprimés avec ces
  chiffres). On distinguera $N_1$ et $N_2$, deux occurrences
  différentes du même symbole $N$ dans une même règle.

\item $S$ est le symbol initial

\item Pour tout noeud $N$ ou $B$ de l'arbre de dérivation, $v$ est un
  attribut synthétisé et $s$ un attribut hérité. Le premier contient
  la valeur du nombre binaire, le second correspond au décalage du
  chiffre à partir de la droite.

\end{itemize}

\begin{tabbing}
$N$ \= $\rightarrow$ \= $B$ \hspace{1in} \= $v(N) = v(B), s(B) = s(N)$\\
$N_1$ \> $\rightarrow$ \> $N_2 B$ \> $v(N_1) = v(N_2)+v(B), s(N_2) = s(N_1)+1, s(B)=s(N_1)$\\
$B$ \> $\rightarrow$ \> $0$ \> $v(B) = 0$\\
$B$ \> $\rightarrow$ \> $1$ \> $v(B)=2^{s(B)}$\\
$S$ \> $\rightarrow$ \> $N$ \> $s(N)=0$\\
\end{tabbing}

\begin{enumerate}
\item Décrire dans le détail le calcul de la valeur décimale du nombre
1001. On dessinera un arbre de dérivation décoré d'un graphe des
attributs hérités et d'un graphe des attributs synthétisés.

\item Pour quelle(s) raison(s) n'est-il pas possible d'écrire une
  grammaire \textit{YACC} qui implémente immédiatement la grammaire
  précédente?

\item Tenter d'écrire une grammaire \textit{YACC} qui implémente cette
  grammaire en utilisant les différents outils de la programmation
  impérative C.

\end{enumerate}

\end{exercice}

\bibliographystyle{apalike}
\bibliography{biblio}

\end{document}
