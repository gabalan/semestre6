%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "c3a.h"

int yylex();
void yyerror(const char*);

extern int yylineno;  // defined and maintained in lex
extern char *yytext;  // defined and maintained in lex

/* **************************************************
 * La machine virtuelle qui va faire tourner le code
 ************************************************** */
extern struct Machine *machine;

int inheritedMaxRegister;

%}

%error-verbose
%start program

%union{
	int intval;
	struct C3a *c3aval;
        int opval;
	struct Address *addressval;
}

%token TOKEN_AFF TOKEN_IF TOKEN_SKIP TOKEN_GOTO TOKEN_PUSH TOKEN_POP TOKEN_PRINT TOKEN_PRINTLN TOKEN_PARAM TOKEN_CALL TOKEN_RETURN TOKEN_MALLOC TOKEN_FREE TOKEN_READ TOKEN_PLUS TOKEN_MINUS TOKEN_TIMES TOKEN_DIV TOKEN_AND TOKEN_OR TOKEN_NOT TOKEN_LT TOKEN_LE TOKEN_GT TOKEN_GE TOKEN_EQ TOKEN_NE TOKEN_STATIC TOKEN_STACK TOKEN_HEAP TOKEN_STOP

%token<intval> INTEGER REGISTER 
%type<c3aval> stms stm c3a
%type<opval> binop unop
%type<addressval> register int int32 register_or_int32 register_or_int array
%type<intval> decl_static
%%

program:
	{inheritedMaxRegister = 0;} decl_static stms
	{
	  // to do...
	}
	;

decl_static:
	'#' TOKEN_STATIC INTEGER '\n' {$$=$3;}
	;

stms:
	stm stms {$$ = $1; $$->next=$2; }
	| stm {$$ = $1; }
	;

stm:
	INTEGER c3a '\n' {$$ = $2; $$->line = $1;}
	;

c3a:
	register TOKEN_AFF register binop register {$$ = new_C3a(0, BINOP, $4, $1, $3, $5);}
	|register TOKEN_AFF unop register {$$ = new_C3a(0, UNOP, $3, $1, $4, NULL);}
	|TOKEN_SKIP {$$ = new_C3a(0, SKIP, 0, NULL, NULL, NULL);}
	|register TOKEN_AFF register_or_int32 {$$ = new_C3a(0, COPY_TO_REGISTER, 0, $1, $3, NULL);}
	|TOKEN_GOTO int {$$ = new_C3a(0, GOTO, 0, $2, NULL, NULL);}
	|TOKEN_IF register TOKEN_GOTO int {$$ = new_C3a(0, IF, 0, $2, $4, NULL);}
	|TOKEN_PUSH int {$$ = new_C3a(0, PUSH, 0, $2, NULL, NULL);}
	|TOKEN_PARAM register {$$ = new_C3a(0, PARAM, 0, $2, NULL, NULL);}
	|register TOKEN_AFF TOKEN_CALL int {$$ = new_C3a(0, CALL, 0, $1, $4, NULL);}
	|TOKEN_RETURN register {$$ = new_C3a(0, RETURN, 0, $2, NULL, NULL);}
	|register TOKEN_AFF array '[' register_or_int ']' {$$ = new_C3a(0, MEMORY_TO_REGISTER, 0, $1, $3, $5);}
	|array '[' register_or_int ']' TOKEN_AFF register {$$ = new_C3a(0, REGISTER_TO_MEMORY, 0, $1, $3, $6);}
	|register TOKEN_AFF TOKEN_MALLOC int {$$ = new_C3a(0, MALLOC, 0, $1, $4, NULL);}
	|TOKEN_FREE register {$$ = new_C3a(0, FREE, 0, $2, NULL, NULL);}
	|TOKEN_PRINT register int {$$ = new_C3a(0, PRINT, 0, $2, $3, NULL);}
	|register TOKEN_AFF TOKEN_READ {$$ = new_C3a(0, READ, 0, $1, NULL, NULL);}
	|TOKEN_STOP {$$ = new_C3a(0, STOP, 0, NULL, NULL, NULL);}
	;

register_or_int32:
	register {$$ = $1;}
	|int32 {$$ = $1;}
	;
register_or_int:
	register {$$ = $1;}
	|int {$$ = $1;}
	;
binop:
	TOKEN_PLUS {$$ = C3A_PLUS;}
	|TOKEN_MINUS {$$ = C3A_MINUS;}
	|TOKEN_TIMES {$$ = C3A_TIMES;}
	|TOKEN_DIV {$$ = C3A_DIV;}
	|TOKEN_AND {$$ = C3A_AND;}
	|TOKEN_OR {$$ = C3A_OR;}
	|TOKEN_LT {$$ = C3A_LT;}
	|TOKEN_LE {$$ = C3A_LE;}
	|TOKEN_GT {$$ = C3A_GT;}
	|TOKEN_GE {$$ = C3A_GE;}
	|TOKEN_EQ {$$ = C3A_EQ;}
	|TOKEN_NE {$$ = C3A_NE;}
	;
		 
unop:
	TOKEN_MINUS {$$ = C3A_UMINUS;}
	|TOKEN_NOT {$$ = C3A_NOT;}
	;

register:
	REGISTER {$$ = new_Address($1, C3A_REGISTER); if (inheritedMaxRegister < $1) inheritedMaxRegister=$1;}
	;

int32:
	INTEGER {$$ = new_Address($1, C3A_INT32);}
	;
int:
	INTEGER {$$ = new_Address($1, C3A_INT);}
	;
array:
	TOKEN_STATIC {$$ = new_Address(0, C3A_STATIC);}
	|TOKEN_STACK {$$ = new_Address(0, C3A_STACK);}
	|TOKEN_HEAP {$$ = new_Address(0, C3A_HEAP);}
	;

%%

void yyerror(const char *s){
  if (yytext)
    fprintf(stderr, "%s at symbol '%s' on line %d\n", s, yytext, yylineno);
  else
    fprintf(stderr, "%s\n", s);
}
