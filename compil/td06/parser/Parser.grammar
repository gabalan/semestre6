%class "ParserExp";

%import "java.util.ArrayList";
%import "java.util.HashMap";

%embed {:
  public HashMap<String,Node> symtab = new HashMap<String,Node> ();

  public CodeList cl = new CodeList ();

  static class Events extends beaver.Parser.Events
  {
    public void syntaxError (Symbol token)
    {
      System.err.format ("Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
        Symbol.getLine (token.getStart ()),
        Symbol.getColumn (token.getStart ()),
        Terminals.NAMES[token.getId ()]);
    }
  }
:};

%init {:
  report = new Events ();
:};

%terminals LPAR, RPAR, SEMICOLON;
%terminals ASSIGN;
%terminals MINUS, PLUS, STAR;
%terminals IDENT;
%terminals CONST_INT;
%terminals TYPE_INT;

%goal programme;

%left PLUS, MINUS;

%typeof instructions, instruction, instruction_simple = "Node";
%typeof declaration, affectation = "Node";
%typeof expression, terme, facteur = "Node";
%typeof type_simple = "Type";
%typeof IDENT = "String";
%typeof CONST_INT = "int";

programme
  = instructions.i
    {:
      i.linearize (cl);
      System.out.format ("Programme :\n%s\n", cl.toString ());
      return (i);
    :}
  ;

instructions
  = instructions.i1 instruction.i2
    {: return new NodeSeq (i1, i2); :}
  | instruction
  ;

instruction
  = instruction_simple.i SEMICOLON
    {: return i; :}
  ;

instruction_simple
  = declaration
  | affectation
  |
    {: return new NodeNop (); :}
  ;

declaration
  = type_simple.t IDENT.i
    {:
      Node n = symtab.get (i);
      if (n != null)
        System.err.format ("Identifiant %s redéfini\n", i);
      else {
        n = new NodeIdent (i, t);
        symtab.put (i, n);
      }
      return new NodeNop ();
    :}
  ;

affectation
  = IDENT.l ASSIGN expression.r
    {:
      Node n = symtab.get (l);
      if (n == null) {
        System.err.format ("Identifiant %s inconnu\n", l);
        return new NodeNop ();
      }
      return new NodeAssign (n, r);
    :}
  ;

type_simple
  = TYPE_INT
    {: return new TypeInt (); :}
  ;

expression
  = terme.t PLUS expression.e
    {: return new NodeOp ("+", t, e); :}
  | terme.t MINUS expression.e
    {: return new NodeOp ("-", t, e); :}
  | terme
  ;

terme
  = facteur.f STAR terme.t
    {: return new NodeOp ("*", f, t); :}
  | facteur
  ;

facteur
  = PLUS facteur.f
    {: return f; :}
  | MINUS facteur.f
    {: return new NodeOp ("-", f); :}
  | LPAR expression.e RPAR
    {: return e; :}
  | IDENT.s
    {:
      Node n = symtab.get (s);
      if (n == null)
        System.err.format ("Identifiant %s inconnu\n", s);
      return n;
    :}
  | CONST_INT.v
    {: return new NodeConstInt (v); :}
  ;
