import beaver.*;
import nodetree.Aff;
import nodetree.Declaration;
import nodetree.Node;
import nodetree.Operation;
import nodetree.Seq;

import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obaKbFmr0CXESbT2C44afO2hGz82Gaf4ezS6Chon7na$Z1h6KfPJFp70S2wgskFiyyswa" +
		"i6S0bEfX15JNK4SWrmfzN2qraMC7wD4u4iqWGOmxps41R$OBcLSsRsbz4HTxHG5lUP8mbf8" +
		"Za5SjOan6$y$CfPvhi$BuS0jssCfK3VSJjOgtKp9Tptg$ovzZt6d7dkcg3DQ1x1Or3qZE$R" +
		"tf0Ziaf6P0J4f5pqYU9pHsHp7pBj6EwHSwyBs3ic5uKDH4Pad5vRXACxPBVBVczOcVJWMbl" +
		"md$q$xsxkSWN#S2Va2Vo8aFcH$90xhL#9xToGtqcdopu#phcW3XUEk2jdPBGfxoFltfCpN6" +
		"yIqZyXG8Z94x9lW7hbKzI");


static public class MyEvents extends beaver.Parser.Events {

	public void syntaxError(Symbol token) {
		System.err.print("Erreur de syntaxe ligne ");
		System.err.println(Symbol.getLine(token.getStart()));
		System.err.print("Token inattendu: ");
		System.err.println(Terminals.NAMES[token.getId()]);
	}
};

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] program = instruction_list
			new Action() {	// [1] instruction_list = instruction_list.list instruction.inst
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_inst = _symbols[offset + 2];
					final Node inst = (Node) _symbol_inst.value;
					return new Seq(list,inst);
				}
			},
			new Action() {	// [2] instruction_list = instruction.inst
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_inst = _symbols[offset + 1];
					final Node inst = (Node) _symbol_inst.value;
					return inst;
				}
			},
			new Action() {	// [3] instruction = instruction_simple.Inst SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_Inst = _symbols[offset + 1];
					final Node Inst = (Node) _symbol_Inst.value;
					 return inst;
				}
			},
			new Action() {	// [4] instruction_simple = declaration.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_d = _symbols[offset + 1];
					final Node d = (Node) _symbol_d.value;
					return d ;
				}
			},
			new Action() {	// [5] instruction_simple = affectation.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Node a = (Node) _symbol_a.value;
					return a;
				}
			},
			new Action() {	// [6] declaration = type_simple.ts identificateur.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ts = _symbols[offset + 1];
					final Node ts = (Node) _symbol_ts.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					return new Declaration(ts,id);
				}
			},
			new Action() {	// [7] affectation = identificateur.id EQ expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Node e = (Node) _symbol_e.value;
					return new Aff(id,e);
				}
			},
			Action.RETURN,	// [8] type_simple = INT
			new Action() {	// [9] expression = terme.t PLUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Node t = (Node) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Node e = (Node) _symbol_e.value;
					return new Operation(t,e,"PLUS");
				}
			},
			new Action() {	// [10] expression = terme.t MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Node t = (Node) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Node e = (Node) _symbol_e.value;
					return new Operation(t,e,"MINUS");
				}
			},
			new Action() {	// [11] expression = terme.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Node t = (Node) _symbol_t.value;
					return new Operation(t);
				}
			},
			new Action() {	// [12] terme = facteur.fact TIMES terme.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol fact = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Node t = (Node) _symbol_t.value;
					return new Operation(fact,t,"TIMES");
				}
			},
			Action.RETURN,	// [13] terme = facteur
			new Action() {	// [14] facteur = PLUS facteur.fact
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol fact = _symbols[offset + 2];
					return new Operation();
				}
			},
			new Action() {	// [15] facteur = MINUS facteur.fact
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol fact = _symbols[offset + 2];
					return new Operation(fact,"MINUS");
				}
			},
			new Action() {	// [16] facteur = LPAR expression RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					return e ;
				}
			},
			new Action() {	// [17] facteur = identificateur.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new Id(id);
				}
			},
			new Action() {	// [18] facteur = valeur_entiere.ent
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ent = _symbols[offset + 1];
					final Integer ent = (Integer) _symbol_ent.value;
					return new IntE(ent);
				}
			}
		};


	report = new MyEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
